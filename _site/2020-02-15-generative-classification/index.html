<!DOCTYPE html>
<html lang="en">
  <!-- Beautiful Jekyll | MIT license | Copyright Dean Attali 2016 -->
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, viewport-fit=cover">

  <title>Generative methods for classification</title>

  <meta name="author" content="Andreea Mușat" />

  

  <link rel="alternate" type="application/rss+xml" title="Website Title - No description." href="http://localhost:4000/feed.xml" />

  

  

  


  
    
      
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.0/css/font-awesome.min.css" />


    
  

  
    
      <link rel="stylesheet" href="/css/bootstrap.min.css" />
    
      <link rel="stylesheet" href="/css/bootstrap-social.css" />
    
      <link rel="stylesheet" href="/css/main.css" />
    
  

  
    
      <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
    
      <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
    
  

  

  

  

    <!-- Facebook OpenGraph tags -->
  

  
  <meta property="og:title" content="Generative methods for classification" />
  

   
  <meta property="og:description" content="Prerequisites Basic calculus (logarithm rules, computing derivatives, properties of derivatives, chain rule for derivatives) Linear algebra (properties of traces, matrix inverses, determinants, properties of symmetric matrices) Basic probability and bayesian statistics notions (prior, posterior, Bayes’ rule, joint probability, independence, probability chain rule, Gaussian distribution, categorical distribution, most of them can...">
  


  <meta property="og:type" content="website" />

  
  <meta property="og:url" content="http://localhost:4000/2020-02-15-generative-classification/" />
  <link rel="canonical" href="http://localhost:4000/2020-02-15-generative-classification/" />
  

  
  <meta property="og:image" content="http://localhost:4000/img/avatar-icon.png" />
  


  <!-- Twitter summary cards -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@" />
  <meta name="twitter:creator" content="@" />

  
  <meta name="twitter:title" content="Generative methods for classification" />
  

  
  <meta name="twitter:description" content="Prerequisites Basic calculus (logarithm rules, computing derivatives, properties of derivatives, chain rule for derivatives) Linear algebra (properties of traces, matrix inverses, determinants, properties of symmetric matrices) Basic probability and bayesian statistics notions (prior, posterior, Bayes’ rule, joint probability, independence, probability chain rule, Gaussian distribution, categorical distribution, most of them can...">
  

  
  <meta name="twitter:image" content="http://localhost:4000/img/avatar-icon.png" />
  

  

  

</head>


  <body>

    

  
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button><a class="navbar-brand" href="http://localhost:4000/">Website Title</a></div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
          <li><a href="/aboutme">About Me</a></li></ul>
    </div>

	
	<div class="avatar-container">
	  <div class="avatar-img-border">
	    <a href="http://localhost:4000/">
	      <img class="avatar-img" src="/img/avatar-icon.png" />
		</a>
	  </div>
	</div>
	

  </div>
</nav>


    
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
>
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://vincenttam.github.io/javascripts/MathJaxLocal.js"
>
</script>

<!-- TODO this file has become a mess, refactor it -->





<header class="header-section ">

<div class="intro-header no-img">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-heading">
          <h1>Generative methods for classification</h1>
		  
		  
		  
		  <span class="post-meta">Posted on February 15, 2020</span>
		  
        </div>
      </div>
    </div>
  </div>
</div>
</header>





<div class="container">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      
      

      <article role="main" class="blog-post">
        <h4 id="prerequisites">Prerequisites</h4>

<ul>
  <li>Basic calculus (logarithm rules, computing derivatives, properties of derivatives, chain rule for derivatives)</li>
  <li>Linear algebra (properties of traces, matrix inverses, determinants, properties of symmetric matrices)</li>
  <li>Basic probability and bayesian statistics notions (prior, posterior, Bayes’ rule, joint probability, independence, probability chain rule, Gaussian distribution, categorical distribution, most of them can be found <a href="https://www.cs.princeton.edu/~bee/courses/scribe/lec_08_26_2013.pdf">here</a>)</li>
  <li>Optimization concepts (convex and concave functions, finding extrema points, method of Lagrange multipliers)</li>
  <li>Matrix calculus (gradients and their properties, some identities involving gradients)</li>
</ul>

<h3 id="probabilistic-framework-for-generative-classification">Probabilistic framework for generative classification</h3>

<p>Classification is the problem of assigning a discrete label (class) to a data point. Unlike discriminant methods, where the class is assigned directly, without any measure of uncertainty, a generative approach models the joint probability of the data:</p>

<p>\begin{equation}
\overbrace{p(\boldsymbol{x}, y)}^{\text{joint}} = 
\underbrace{p(y)}_{\text{class prior}} \overbrace{p(\boldsymbol{x}\mid y)}^{\text{class conditional}} \tag{1}
\end{equation}</p>

<p>where <script type="math/tex">\boldsymbol{x} \in \mathbb{R}^D</script> (note the usage of bold symbols for vectors) is a point to be classified and <script type="math/tex">y \in \{1, 2, \dots K \}</script> is its label, with <script type="math/tex">K</script> being the total number of classes.</p>

<p>Intuitively, the prior represents how often a class is expected to appear and the class conditional is the probability density function (assuming <script type="math/tex">X</script> are continous) of the data having the class indicated by y.</p>

<p>Using this framework, the posterior probability of each class <script type="math/tex">k</script> for a new point <script type="math/tex">\boldsymbol{x}_{new}</script> is given by Bayes’ rule:</p>

<script type="math/tex; mode=display">\begin{equation}
p(y = k \mid \boldsymbol{x}_{new}) = 
\frac{p(\boldsymbol{x}_{new} \mid y = k) p(y = k)}{p(\boldsymbol{x}_{new})} \propto 
p(\boldsymbol{x}_{new} \mid y = k) p(y = k) \tag{2}
\end{equation}</script>

<p>where we used the fact that <script type="math/tex">p(\boldsymbol{x}_{new})</script> is just a scaling factor that appears in all posterior probabilities and thus can be ignored.</p>

<p>Now, <script type="math/tex">\boldsymbol{x}_{new}</script> will be assigned to the class which yields the highest posterior probability:</p>

<script type="math/tex; mode=display">\begin{equation}
y_{new} = \arg\max_{k} p(y = k \mid \boldsymbol{x}_{new}) \tag{3}
\end{equation}</script>

<h3 id="normally-distributed-inputs">Normally distributed inputs</h3>

<p>Up to this point, we have only established the probabilistic framework we will use, but we haven’t made any assumption about the distribution of the data within each class. We will continue by making some assumptions about the underlying distributions of the data and then estimating the parameters of these distributions.</p>

<h4 id="modelling-the-class-priors-and-class-conditionals">Modelling the class priors and class conditionals</h4>

<p>We will assume that the class conditionals are <a href="https://en.wikipedia.org/wiki/Multivariate_normal_distribution">multivariate Gaussian distributions</a>:</p>

<script type="math/tex; mode=display">\begin{equation}
p(\boldsymbol{x} \mid y = k) = 
\mathcal{N}(\boldsymbol{x} \mid \boldsymbol{\mu}_k, \boldsymbol{\Sigma}_k) = 
\frac{1}{(2 \pi)^{\frac{D}{2}}} \frac{1}{\det({\boldsymbol{\Sigma}_k})^{\frac{1}{2}}} e^{-\frac{1}{2} (\boldsymbol{x} - \boldsymbol{\mu}_k)^T \boldsymbol{\Sigma}_k^{-1} (\boldsymbol{x} - \boldsymbol{\mu}_k)} \tag{4}
\end{equation}</script>

<p>Because there are <script type="math/tex">K</script> classes and their probabilities sum to one, the natural choice for the class priors is a <a href="https://en.wikipedia.org/wiki/Categorical_distribution">categorical distribution</a> with parameters <script type="math/tex">\boldsymbol{\pi} = \begin{bmatrix} \pi_1, \pi_2, \dots, \pi_K \end{bmatrix}</script>:</p>

<script type="math/tex; mode=display">\begin{equation}
p(y = k) = \pi_k, \forall k \in \{1, 2, \dots K\} \tag{5}
\end{equation}</script>

<h3 id="maximum-likelihood-estimation-mle-of-the-parameters">Maximum Likelihood Estimation (MLE) of the parameters</h3>

<p>Before moving on, let’s recap what we have until now: we modeled the class priors using a categorical distribution with parameters <script type="math/tex">\boldsymbol{\pi}</script> and the class conditionals using Gaussian distributions with means <script type="math/tex">\boldsymbol{\mu}_k</script> and covariance matrices <script type="math/tex">\boldsymbol{\Sigma}_k, \forall k \in \{1, 2, \dots k \}</script>. However, the parameters of these distributions are not known, so we must use the dataset in order to estimate them.</p>

<h4 id="maximum-likelihood-estimation-mle-refresher">Maximum Likelihood Estimation (MLE) refresher</h4>

<p>MLE is a method for estimating the parameters <script type="math/tex">\boldsymbol{\theta}</script> of a probability distribution <script type="math/tex">p(\boldsymbol{x} \mid \boldsymbol{\theta})</script> by maximizing the likelihood function of a dataset <script type="math/tex">\mathcal{D} = \{\boldsymbol{x}_1, \dots, \boldsymbol{x}_n\}</script> consisting of <script type="math/tex">n</script> i.i.d samples:</p>

<script type="math/tex; mode=display">\begin{equation}
\boldsymbol{\hat{\theta}} = 
\arg\max_{\boldsymbol{\theta}} \underbrace{\mathcal{L}( \mathcal{D} \mid \boldsymbol{\theta})}_{\text{likelihood}} =
\arg\max_{\boldsymbol{\theta}} \underbrace{\prod_{i=1}^N p(\boldsymbol{x}_i \mid \boldsymbol{\theta})}_{\text{likelihood}} \tag{6}
\end{equation}</script>

<p>Because it is inconvenient to maximize a function containing a product, we can make use of the fact that the logarithm function transforms products into sums and is non-decreasing, thus preserving the extrema of a function:</p>

<script type="math/tex; mode=display">\begin{equation}
\boldsymbol{\hat{\theta}} =
\arg\max_{\boldsymbol{\theta}} \underbrace{\log \big( \prod_{i=1}^N p(\boldsymbol{x}_i \mid \boldsymbol{\theta}) \big)}_{\text{log likelihood}} = 
\arg\max_{\boldsymbol{\theta}} \underbrace{\sum_{i=1}^N \log p(\boldsymbol{x}_i \mid \boldsymbol{\theta})}_{\text{log likelihood}}  \tag{7}
\end{equation}</script>

<p>Usually, when <script type="math/tex">\boldsymbol{\theta}</script> is unconstrained, the maximizer of the log likelihood function is found by setting the derivative w.r.t <script type="math/tex">\boldsymbol{\theta}</script> (or gradient if working with a multidimensional parameter) to zero and proving that the maximized function is concave, which is sufficient to conclude that extrema point found is indeed a maximizer. If <script type="math/tex">\boldsymbol{\theta}</script> is constrained, then a different method such as the method of Lagrange multipliers should be used.</p>

<h4 id="modeling-the-joint-distribution-of-a-sample">Modeling the joint distribution of a sample</h4>

<p>Using the class priors and class conditionals assumed above, the joint distribution of an input and its corresponding label can be written as:</p>

<script type="math/tex; mode=display">p(\boldsymbol{x}, y = k) = p(y = k) p(\boldsymbol{x} \mid y = k) = 
\pi_k \mathcal{N}(\boldsymbol{x} \mid \boldsymbol{\mu}_k, \boldsymbol{\Sigma}_k) =</script>

<script type="math/tex; mode=display">\begin{equation}
\prod_{i=1}^K (\pi_i \mathcal{N}(\boldsymbol{x} \mid \boldsymbol{\mu}_i, \boldsymbol{\Sigma}_i))^{I[y = i]} \tag{8}
\end{equation}</script>

<p>where <script type="math/tex">I[\text{condition}]</script> is the indicator function (see <a href="https://en.wikipedia.org/wiki/Iverson_bracket">Iverson bracket</a>) which evaluates to 1 only if the condition inside the brackets is true.</p>

<h4 id="log-likelihood-of-the-dataset">Log likelihood of the dataset</h4>

<p>Assuming we have a dataset consisting of N <a href="https://en.wikipedia.org/wiki/Independent_and_identically_distributed_random_variables">independent and identically distributed</a> samples, <script type="math/tex">\mathcal{D} = \{(\boldsymbol{x}_i, y_i)_{i=1}^N\}</script>, we can write the likelihood of the data as the product of the probabilities of all samples:</p>

<script type="math/tex; mode=display">\begin{equation}
\mathcal{L}(\mathcal{D} \mid \boldsymbol{\pi}, \boldsymbol{\mu}, \boldsymbol{\Sigma}) = 
\prod_{i=1}^N \prod_{k=1}^K (\pi_k \mathcal{N}(\boldsymbol{x}_i \mid \boldsymbol{\mu}_k, \boldsymbol{\Sigma}_k))^{I[y_i = k]} \tag{9}
\end{equation}</script>

<p>Thus, the log likelihood of the dataset will be:</p>

<script type="math/tex; mode=display">\log \mathcal{L}(\mathcal{D} \mid \boldsymbol{\pi}, \boldsymbol{\mu}, \boldsymbol{\Sigma}) = 
\sum_{i=1}^N \sum_{k=1}^K \log(\pi_k \mathcal{N}(\boldsymbol{x}_i \mid \boldsymbol{\mu}_k, \boldsymbol{\Sigma}_k))^{I[y_i = k]} =</script>

<script type="math/tex; mode=display">\begin{equation}
\sum_{i=1}^N \sum_{k=1}^K I[y_i = k] \big( \log\pi_k + \log\mathcal{N}(\boldsymbol{x}_i \mid \boldsymbol{\mu}_k, \boldsymbol{\Sigma}_k)) \big) \tag{10}
\end{equation}</script>

<h4 id="estimating-boldsymbolpi_k">Estimating <script type="math/tex">\boldsymbol{\pi}_k</script></h4>

<p>We first notice that <script type="math/tex">\pi_k</script> appears in the log likelihood only through the term <script type="math/tex">\log \pi_k</script>, so we can ignore the other term which doesn’t depend on it:</p>

<script type="math/tex; mode=display">\begin{equation}
\log \mathcal{L}(\mathcal{D} \mid \boldsymbol{\pi}, \boldsymbol{\mu}, \boldsymbol{\Sigma}) \propto 
\sum_{i=1}^N \sum_{k=1}^K I[y_i = k] \log\pi_k \tag{11}
\end{equation}</script>

<p>Because the <script type="math/tex">\pi_k</script>’s are constrained such that <script type="math/tex">\sum_{k=1}^K \pi_k = 1</script> (as they are the parameters of a categorical distribution), we can use the method of Lagrange multipliers to find the maximizer of the log likelihood subject to this constraint.</p>

<p>We formulate the Lagrangian:</p>

<script type="math/tex; mode=display">\begin{equation}
\mathcal{L}(\boldsymbol{\pi}, \lambda) = 
\sum_{i=1}^N \sum_{k=1}^K \Big( I[y_i = k] \log\pi_k \Big) - \lambda (\sum_{k=1}^K \pi_k - 1) \tag{12}
\end{equation}</script>

<p>which we can reorder a bit and unclutter by noticing that the interior sum <script type="math/tex">\sum_{i=1}^N  I[y_i = k]</script> is just the number of data points which have class <script type="math/tex">k</script>, which we can denote as <script type="math/tex">N_k</script>:</p>

<script type="math/tex; mode=display">\mathcal{L}(\boldsymbol{\pi}, \lambda) = 
\sum_{k=1}^K \log\pi_k \underbrace{\sum_{i=1}^N  I[y_i = k]}_{N_k} - \lambda (\sum_{k=1}^K \pi_k - 1) =</script>

<script type="math/tex; mode=display">\begin{equation}
\sum_{k=1}^K N_k \log\pi_k  - \lambda (\sum_{k=1}^K \pi_k - 1) \tag{13}
\end{equation}</script>

<p>Taking the derivative of the Lagrangian w.r.t <script type="math/tex">\pi_j</script> and setting it to zero, we obtain:</p>

<script type="math/tex; mode=display">\begin{equation}
\frac{\partial{\mathcal{L}(\boldsymbol{\pi}, \lambda)}}{\partial{\pi_j}} = 
\frac{N_j}{\pi_j} - \lambda \overset{!}{=} 0 \implies \pi_j = \frac{N_j}{\lambda} \tag{14}
\end{equation}</script>

<p>Replacing <script type="math/tex">\pi_j</script> back into the Lagrangian we obtain the dual:</p>

<script type="math/tex; mode=display">g(\lambda) = 
\sum_{k=1}^K N_k log\frac{N_k}{\lambda} - \lambda (\sum_{k=1}^K \frac{N_k}{\lambda} - 1) =
\sum_{k=1}^K N_k log\frac{N_k}{\lambda} + \lambda - \sum_{k=1}^K N_k \implies</script>

<script type="math/tex; mode=display">\frac{d g(\lambda)}{d \lambda} = 
\sum_{k=1}^K N_k \frac{\lambda}{N_k} \Big[ \frac{d}{d \lambda} \frac{N_k}{\lambda} \Big] + 1 = 
\sum_{k=1}^K \frac{-N_k}{\lambda} + 1 \overset{!}{=} 0 \implies</script>

<script type="math/tex; mode=display">\begin{equation}
\frac{1}{\lambda} \sum_{k=1}^K N_k = 1 \tag{15}
\end{equation}</script>

<p>We remember that <script type="math/tex">N_k</script> was the number of elements in the dataset belonging to class <script type="math/tex">k</script>, so naturally the sum of all <script type="math/tex">N_k</script>’s will be <script type="math/tex">N</script>, the total number of elements in the dataset. Thus, we can conclude that:</p>

<script type="math/tex; mode=display">\begin{equation} 
\lambda = N \implies \pi_j = \frac{N_j}{N}  \tag{16}
\end{equation}</script>

<p>So we arrived at a simple result stating that the estimated probability for each class must be the empirical probability of that class, measured on dataset <script type="math/tex">\mathcal{D}</script>.</p>

<h4 id="estimating-boldsymbolmu_k">Estimating <script type="math/tex">\boldsymbol{\mu}_k</script></h4>

<p>Now, we look at the log likelihood again [10] and only keep the terms containing <script type="math/tex">\boldsymbol{\mu}_k</script>:</p>

<script type="math/tex; mode=display">\log \mathcal{L}(\mathcal{D} \mid \boldsymbol{\pi}, \boldsymbol{\mu}, \boldsymbol{\Sigma}) \propto
\sum_{i=1}^N \sum_{k=1}^K I[y_i = k] \log\mathcal{N}(\boldsymbol{x}_i \mid \boldsymbol{\mu}_k, \boldsymbol{\Sigma}_k)) =</script>

<script type="math/tex; mode=display">\sum_{i=1}^N \sum_{k=1}^K I[y_i = k] \Big( 
		\underbrace{\log \frac{1}{(2 \pi)^{\frac{D}{2}}} + 
					\log \frac{1}{\det(\boldsymbol{\Sigma_k})^{\frac{1}{2}}}}_{\text{ct. w.r.t } \boldsymbol{\mu_k}} -
		\frac{1}{2} (\boldsymbol{x_i} - \boldsymbol{\mu}_k)^T \boldsymbol{\Sigma}_k^{-1} (\boldsymbol{x_i} - \boldsymbol{\mu}_k)
		\Big) \propto</script>

<script type="math/tex; mode=display">\sum_{i=1}^N \sum_{k=1}^K I[y_i = k] \Big( 
-\frac{1}{2} (\boldsymbol{x_i} - \boldsymbol{\mu}_k)^T \boldsymbol{\Sigma}_k^{-1} (\boldsymbol{x_i} - \boldsymbol{\mu}_k)
		\Big) \implies</script>

<script type="math/tex; mode=display">\nabla_{\boldsymbol{\mu_j}}{\log \mathcal{L}(\mathcal{D} \mid \boldsymbol{\pi}, \boldsymbol{\mu}, \boldsymbol{\Sigma})} =
\sum_{i=1}^N I[y_i = j]  \Big( -\frac{1}{2} 2 \boldsymbol{\Sigma}_k^{-1} (\boldsymbol{x_i} - \boldsymbol{\mu}_j)
\Big) \overset{!}{=} 0 \implies</script>

<script type="math/tex; mode=display">\sum_{i=1}^N I[y_i = j]  (\boldsymbol{x_i} - \boldsymbol{\mu}_j) = 0 \implies
\sum_{i=1}^N I[y_i = j] \boldsymbol{x_i} = \boldsymbol{\mu_j} \underbrace{\sum_{i=1}^N I[y_i = j]}_{N_j} \implies</script>

<script type="math/tex; mode=display">\begin{equation}
\boldsymbol{\mu_j} = \frac{1}{N_j} \sum_{i=1}^N I[y_i = j] \boldsymbol{x_i}
\tag{17}
\end{equation}</script>

<p>Again, we arrived at a very simple result: the mean of each class conditional is the empirical mean of all data points belonging to that class.</p>

<h4 id="estimating-boldsymbolsigma_k">Estimating <script type="math/tex">\boldsymbol{\Sigma}_k</script></h4>

<p>Similarly, we find the optimal <script type="math/tex">\boldsymbol{\Sigma_k}</script> by computing the gradient of the log likelihood w.r.t <script type="math/tex">\boldsymbol{\Sigma_k}</script> and setting it to zero.</p>

<script type="math/tex; mode=display">\log \mathcal{L}(\mathcal{D} \mid \boldsymbol{\pi}, \boldsymbol{\mu}, \boldsymbol{\Sigma}) \propto
\sum_{i=1}^N \sum_{k=1}^K I[y_i = k] \log\mathcal{N}(\boldsymbol{x}_i \mid \boldsymbol{\mu}_k, \boldsymbol{\Sigma}_k)) =</script>

<script type="math/tex; mode=display">\sum_{i=1}^N \sum_{k=1}^K I[y_i = k] \Big( 
		\underbrace{\log \frac{1}{(2 \pi)^{\frac{D}{2}}}}_{\text{ct. w.r.t } \boldsymbol{\Sigma_k}} + 
					\log \frac{1}{\det(\boldsymbol{\Sigma_k})^{\frac{1}{2}}} -
		\frac{1}{2} (\boldsymbol{x_i} - \boldsymbol{\mu}_k)^T \boldsymbol{\Sigma}_k^{-1} (\boldsymbol{x_i} - \boldsymbol{\mu}_k)
		\Big) \propto</script>

<script type="math/tex; mode=display">\sum_{i=1}^N \sum_{k=1}^K I[y_i = k] \Big( 
					\log \frac{1}{\det(\boldsymbol{\Sigma_k})^{\frac{1}{2}}} -
		\frac{1}{2} (\boldsymbol{x_i} - \boldsymbol{\mu}_k)^T \boldsymbol{\Sigma}_k^{-1} (\boldsymbol{x_i} - \boldsymbol{\mu}_k)
		\Big) =</script>

<script type="math/tex; mode=display">\begin{equation}
\frac{1}{2} \sum_{i=1}^N \sum_{k=1}^K I[y_i = k] \Big( 
	\log \det(\boldsymbol{\Sigma_k^{-1}}) -
		(\boldsymbol{x_i} - \boldsymbol{\mu}_k)^T \boldsymbol{\Sigma}_k^{-1} (\boldsymbol{x_i} - \boldsymbol{\mu}_k)
		\Big)
\tag{18}
\end{equation}</script>

<p>Because the function is concave in <script type="math/tex">\boldsymbol{\Sigma_j^{-1}}</script>, we can compute the gradient w.r.t <script type="math/tex">\boldsymbol{\Sigma_j^{-1}}</script> directly:</p>

<script type="math/tex; mode=display">\nabla_{\boldsymbol{\Sigma_j^{-1}}}{\log \mathcal{L}(\mathcal{D} \mid \boldsymbol{\pi}, \boldsymbol{\mu}, \boldsymbol{\Sigma})} =</script>

<script type="math/tex; mode=display">\begin{equation}
\small
\frac{1}{2} \sum_{i=1}^N \sum_{k=1}^K I[y_i = k] \Bigg( 
	\nabla_{\boldsymbol{\Sigma_j^{-1}}} \Big( \log \det(\boldsymbol{\Sigma_k^{-1}}) \Big) -
		\nabla_{\boldsymbol{\Sigma_j^{-1}}} \Big( (\boldsymbol{x_i} - \boldsymbol{\mu}_k)^T \boldsymbol{\Sigma}_k^{-1} (\boldsymbol{x_i} - \boldsymbol{\mu}_k) \Big)
		\Bigg)
\tag{19}
\end{equation}</script>

<p>We will compute the two gradients separately. For the first one we will use the log-determinant gradient rule from the table <a href="https://en.wikipedia.org/wiki/Matrix_calculus?fbclid=IwAR1Pci6kG1MD87fkUfx8OZmh-YJVHLzcWBoI1dl3y5sFQb-ucvdxyWa3atQ#Scalar-by-matrix_identities">here</a>, coupled with the fact that <script type="math/tex">\boldsymbol{\Sigma_k}</script> is a covariance matrix, thus symmetric:</p>

<script type="math/tex; mode=display">\nabla_{\boldsymbol{\Sigma_j^{-1}}} \Big( \log \det(\boldsymbol{\Sigma_k^{-1}}) \Big) 
\overset{\frac{\partial \log (\det (\boldsymbol{X}))}{\partial \boldsymbol{X}} = (\boldsymbol{X}^{-1})^T }{=\mathrel{\mkern-3mu}=\mathrel{\mkern-3mu}=}
\left\{
	\begin{array}{ll}
     0 \text{, if } j \neq k \\
     ((\boldsymbol{\Sigma_k}^{-1})^{-1})^T \text{, if } j = k
\end{array} 
\right.</script>

<script type="math/tex; mode=display">\begin{equation}
\overset{\boldsymbol{\Sigma_k} \text{ symm.}}{=}
\left\{
	\begin{array}{ll}
     0 \text{, if } j \neq k \\
     \boldsymbol{\Sigma_k} \text{, if } j = k
\end{array} 
\right. 
\tag{20}
\end{equation}</script>

<p>For the second one, in a similar way, if <script type="math/tex">k \neq j</script>, then the gradient is 0. For <script type="math/tex">k = j</script>, we can notice that the expression under the gradient is a scalar, so we can apply the trace operator on it, as <script type="math/tex">Tr(a) = a, \forall a \in \mathbb{R}</script>. The trace operator has some nice properties, such as the <a href="https://en.wikipedia.org/wiki/Trace_(linear_algebra)#Cyclic_property">cyclic property</a> and <a href="https://en.wikipedia.org/wiki/Trace_(linear_algebra)#Basic_properties">allowing transposing</a>, so using the rule for the gradient of a product of two matrices w.r.t one of the matrices (from the table <a href="https://en.wikipedia.org/wiki/Matrix_calculus?fbclid=IwAR1Pci6kG1MD87fkUfx8OZmh-YJVHLzcWBoI1dl3y5sFQb-ucvdxyWa3atQ#Scalar-by-matrix_identities">here</a>), we get:</p>

<script type="math/tex; mode=display">\nabla_{\boldsymbol{\Sigma_k^{-1}}} \Big( (\boldsymbol{x_i} - \boldsymbol{\mu}_k)^T \boldsymbol{\Sigma}_k^{-1} (\boldsymbol{x_i} - \boldsymbol{\mu}_k) \Big) = 
\nabla_{\boldsymbol{\Sigma_k^{-1}}}  Tr \Big((\boldsymbol{x_i} - \boldsymbol{\mu}_k)^T \boldsymbol{\Sigma}_k^{-1} (\boldsymbol{x_i} - \boldsymbol{\mu}_k) \Big) \overset{\text{cyclic prop.}}{=}</script>

<script type="math/tex; mode=display">\nabla_{\boldsymbol{\Sigma_k^{-1}}}  Tr \Big(\boldsymbol{\Sigma}_k^{-1} (\boldsymbol{x_i} - \boldsymbol{\mu}_k) (\boldsymbol{x_i} - \boldsymbol{\mu}_k)^T \Big) 
\overset{\frac{\partial Tr(\boldsymbol{XA})}{\partial \boldsymbol{X}} = \boldsymbol{A}^T}{=\mathrel{\mkern-3mu}=\mathrel{\mkern-3mu}=}
\Big( (\boldsymbol{x_i} - \boldsymbol{\mu}_k) (\boldsymbol{x_i} - \boldsymbol{\mu}_k)^T \Big)^T =</script>

<script type="math/tex; mode=display">\begin{equation}
(\boldsymbol{x_i} - \boldsymbol{\mu}_k) (\boldsymbol{x_i} - \boldsymbol{\mu}_k)^T 
\tag{21}
\end{equation}</script>

<p>Now, using the results (20) and (21) and plugging them into the expression of the gradient of the log likelihood w.r.t <script type="math/tex">\boldsymbol{\Sigma_j}^{-1}</script> (19), we finally get:</p>

<script type="math/tex; mode=display">\nabla_{\boldsymbol{\Sigma_j^{-1}}}{\log \mathcal{L}(\mathcal{D} \mid \boldsymbol{\pi}, \boldsymbol{\mu}, \boldsymbol{\Sigma})} = 
\frac{1}{2} \sum_{i=1}^N I[y_i = j] \Bigg( 
	\underbrace{\boldsymbol{\Sigma_j}}_{\text{ct. w.r.t i}} -
	(\boldsymbol{x_i} - \boldsymbol{\mu}_j) (\boldsymbol{x_i} - \boldsymbol{\mu}_j)^T 	
		\Bigg)
\overset{!}{=} 0 \implies</script>

<script type="math/tex; mode=display">\boldsymbol{\Sigma_j} \underbrace{\sum_{i=1}^N I[y_i = j]}_{N_j}  =
\sum_{i=1}^N I[y_i = j] (\boldsymbol{x_i} - \boldsymbol{\mu}_j) (\boldsymbol{x_i} - \boldsymbol{\mu}_j)^T \implies</script>

<script type="math/tex; mode=display">\boldsymbol{\Sigma_j} = \frac{1}{N_j} \sum_{i=1}^N I[y_i = j] (\boldsymbol{x_i} - \boldsymbol{\mu}_j) (\boldsymbol{x_i} - \boldsymbol{\mu}_j)^T \tag{22}</script>

<p>which is the MLE estimate of the covariance of the data points having class <script type="math/tex">j</script>.</p>

<h3 id="decision-boundary">Decision boundary</h3>

<p>Now, having estimated the parameters of the assumed distributions, let’s inspect the shape of the decision boundary. The decision boundary is the hypersurface separating data points from 2 different classes, let’s say class <script type="math/tex">i</script> and class <script type="math/tex">j</script>, so the points on this hypersurface have equal posterior probability of being assigned to either of the two classes:</p>

<script type="math/tex; mode=display">\boldsymbol{x} \in \text{DecisionBoundary} \iff p(y = i \mid \boldsymbol{x}) = p(y = j \mid \boldsymbol{x}) \tag{23}</script>

<p>Using Bayes’ rule as in (2), we can write an equivalent condition:</p>

<script type="math/tex; mode=display">\frac{p(\boldsymbol{x} \mid y = i) p(y = i)}{p(\boldsymbol{x})} = \frac{p(\boldsymbol{x} \mid y = j) p(y = j)}{p(\boldsymbol{x})} \iff
\frac{p(\boldsymbol{x} \mid y = i) p(y = i)}{p(\boldsymbol{x} \mid y = j) p(y = j)} = 1 \iff</script>

<script type="math/tex; mode=display">\log \frac{p(\boldsymbol{x} \mid y = i)}{p(\boldsymbol{x} \mid y = j)} + \log \frac{p(y = i)}{p(y = j)} = 0 \iff</script>

<script type="math/tex; mode=display">\log 
	\frac
	{
		\require{cancel} \cancel{\frac{1}{(2 \pi)^{\frac{D}{2}}}} 
		\frac{1}{\det(\boldsymbol{\Sigma_i})^{\frac{1}{2}}}
		e^{-\frac{1}{2} (\boldsymbol{x} - \boldsymbol{\mu_i})^T \boldsymbol{\Sigma_i}^{-1} (\boldsymbol{x} - \boldsymbol{\mu_i})}
	}
	{
		\cancel{\frac{1}{(2 \pi)^{\frac{D}{2}}}}
		\frac{1}{\det(\boldsymbol{\Sigma_j})^{\frac{1}{2}}}
		e^{-\frac{1}{2} (\boldsymbol{x} - \boldsymbol{\mu_j})^T \boldsymbol{\Sigma_j}^{-1} (\boldsymbol{x} - \boldsymbol{\mu_j})}
	} + 
	\log \frac{\pi_i}{\pi_j}
= 0 \iff</script>

<script type="math/tex; mode=display">\frac{1}{2} \log \frac{\det(\boldsymbol{\Sigma_j})}{\det(\boldsymbol{\Sigma_i})}
-\frac{1}{2} (\boldsymbol{x} - \boldsymbol{\mu_i})^T \boldsymbol{\Sigma_i}^{-1} (\boldsymbol{x} - \boldsymbol{\mu_i})
+\frac{1}{2} (\boldsymbol{x} - \boldsymbol{\mu_j})^T \boldsymbol{\Sigma_j}^{-1} (\boldsymbol{x} - \boldsymbol{\mu_j})
+ \log \frac{\pi_i}{\pi_j} = 0</script>

<script type="math/tex; mode=display">\iff</script>

<script type="math/tex; mode=display">\small
(\boldsymbol{x} - \boldsymbol{\mu_j})^T \boldsymbol{\Sigma_j}^{-1} (\boldsymbol{x} - \boldsymbol{\mu_j}) -
(\boldsymbol{x} - \boldsymbol{\mu_i})^T \boldsymbol{\Sigma_i}^{-1} (\boldsymbol{x} - \boldsymbol{\mu_i}) 
+ 2 \log \frac{\pi_i}{\pi_j}
+ \log \frac{\det(\boldsymbol{\Sigma_j})}{\det(\boldsymbol{\Sigma_i})} = 0 \tag{24}</script>

<p>Now, looking at the expression above, we can see that the decision boundary is quadratic. We’ll expand it further to see each coefficient clearly:</p>

<script type="math/tex; mode=display">\boldsymbol{x}^T \boldsymbol{\Sigma_j}^{-1} \boldsymbol{x} -
2 \boldsymbol{x}^T \boldsymbol{\Sigma_j}^{-1} \boldsymbol{\mu_j} +
\boldsymbol{\mu_j}^T \boldsymbol{\Sigma_j}^{-1} \boldsymbol{\mu_j} \\
- \boldsymbol{x}^T \boldsymbol{\Sigma_i}^{-1} \boldsymbol{x} +
2 \boldsymbol{x}^T \boldsymbol{\Sigma_i}^{-1} \boldsymbol{\mu_i} -
\boldsymbol{\mu_i}^T \boldsymbol{\Sigma_i}^{-1} \boldsymbol{\mu_i} + \\
2 \log \frac{\pi_i}{\pi_j}
+ \log \frac{\det(\boldsymbol{\Sigma_j})}{\det(\boldsymbol{\Sigma_i})} = 0 \iff</script>

<script type="math/tex; mode=display">\boldsymbol{x}^T \boldsymbol{A} \boldsymbol{x} + + \boldsymbol{x}^T  \boldsymbol{b} + c \tag{25}</script>

<p>where</p>

<script type="math/tex; mode=display">\boldsymbol{A} = (\boldsymbol{\Sigma_j}^{-1} - \boldsymbol{\Sigma_i}^{-1}), \tag{26}</script>

<script type="math/tex; mode=display">\boldsymbol{b} = -2 (\boldsymbol{\Sigma_j}^{-1} \boldsymbol{\mu_j} - \boldsymbol{\Sigma_i}^{-1} \boldsymbol{\mu_i}), \tag{27}</script>

<script type="math/tex; mode=display">c = \boldsymbol{\mu_j}^T \boldsymbol{\Sigma_j}^{-1} \boldsymbol{\mu_j} 
- \boldsymbol{\mu_i}^T \boldsymbol{\Sigma_i}^{-1} \boldsymbol{\mu_i}
+ 2 \log \frac{\pi_i}{\pi_j}
+ \log \frac{\det(\boldsymbol{\Sigma_i^{-1}})}{\det(\boldsymbol{\Sigma_j^{-1}})}  \tag{28}</script>

<h4 id="linear-discriminant-analysis-for-classification">Linear Discriminant Analysis for classification</h4>

<p>The model above might have too many parameters for some applications, so it can be simplified by assuming that the covariance matrix is the same for all classes, that is <script type="math/tex">\boldsymbol{\Sigma_i} = \boldsymbol{\Sigma}, \forall i \in \{1, 2, \dots k\}</script>, in which case the decision boundary will be linear, because the <script type="math/tex">\boldsymbol{A}</script> term (26) will vanish.</p>

<h3 id="code">Code</h3>

<!-- HTML generated using hilite.me -->
<div style="background: #f0f3f3; overflow:auto;width:auto;border:solid gray;border-width:.0em .0em .0em .0em;padding:.0em .0em;"><pre style="margin: 0; line-height: 125%"><span style="color: #006699; font-weight: bold">import</span> <span style="color: #00CCFF; font-weight: bold">numpy</span> <span style="color: #006699; font-weight: bold">as</span> <span style="color: #00CCFF; font-weight: bold">np</span>
<span style="color: #006699; font-weight: bold">from</span> <span style="color: #00CCFF; font-weight: bold">plotly</span> <span style="color: #006699; font-weight: bold">import</span> subplots
<span style="color: #006699; font-weight: bold">import</span> <span style="color: #00CCFF; font-weight: bold">plotly.graph_objs</span> <span style="color: #006699; font-weight: bold">as</span> <span style="color: #00CCFF; font-weight: bold">go</span>
<span style="color: #006699; font-weight: bold">import</span> <span style="color: #00CCFF; font-weight: bold">plotly.offline</span> <span style="color: #006699; font-weight: bold">as</span> <span style="color: #00CCFF; font-weight: bold">py</span>
<span style="color: #006699; font-weight: bold">from</span> <span style="color: #00CCFF; font-weight: bold">scipy.stats</span> <span style="color: #006699; font-weight: bold">import</span> multivariate_normal <span style="color: #006699; font-weight: bold">as</span> gaussian


<span style="color: #006699; font-weight: bold">class</span> <span style="color: #00AA88; font-weight: bold">GenerativeGaussianClassifier</span>(<span style="color: #336666">object</span>):
  <span style="color: #006699; font-weight: bold">def</span> <span style="color: #CC00FF">__init__</span>(<span style="color: #336666">self</span>, K):
    <span style="color: #336666">self</span><span style="color: #555555">.</span>K <span style="color: #555555">=</span> K

  <span style="color: #006699; font-weight: bold">def</span> <span style="color: #CC00FF">fit</span>(<span style="color: #336666">self</span>, Xs, ys):
    cls_counts <span style="color: #555555">=</span> np<span style="color: #555555">.</span>bincount(ys)
    get_mean <span style="color: #555555">=</span> <span style="color: #006699; font-weight: bold">lambda</span> k: Xs[ys <span style="color: #555555">==</span> k]<span style="color: #555555">.</span>mean(<span style="color: #FF6600">0</span>)
    get_cov <span style="color: #555555">=</span> <span style="color: #006699; font-weight: bold">lambda</span> k: np<span style="color: #555555">.</span>dot((Xs[ys <span style="color: #555555">==</span> k] <span style="color: #555555">-</span> <span style="color: #336666">self</span><span style="color: #555555">.</span>mus[k])<span style="color: #555555">.</span>T, \
    	                        Xs[ys <span style="color: #555555">==</span> k] <span style="color: #555555">-</span> <span style="color: #336666">self</span><span style="color: #555555">.</span>mus[k]) <span style="color: #555555">/</span> cls_counts[k]
    get_cls_cond <span style="color: #555555">=</span> <span style="color: #006699; font-weight: bold">lambda</span> k: gaussian(mean<span style="color: #555555">=</span><span style="color: #336666">self</span><span style="color: #555555">.</span>mus[k], cov<span style="color: #555555">=</span><span style="color: #336666">self</span><span style="color: #555555">.</span>gammas[k])

    <span style="color: #336666">self</span><span style="color: #555555">.</span>pis <span style="color: #555555">=</span> cls_counts <span style="color: #555555">/</span> <span style="color: #336666">len</span>(ys)
    <span style="color: #336666">self</span><span style="color: #555555">.</span>mus <span style="color: #555555">=</span> np<span style="color: #555555">.</span>stack([get_mean(k) <span style="color: #006699; font-weight: bold">for</span> k <span style="color: #000000; font-weight: bold">in</span> <span style="color: #336666">range</span>(<span style="color: #336666">self</span><span style="color: #555555">.</span>K)])
    <span style="color: #336666">self</span><span style="color: #555555">.</span>gammas <span style="color: #555555">=</span> np<span style="color: #555555">.</span>stack([get_cov(k) <span style="color: #006699; font-weight: bold">for</span> k <span style="color: #000000; font-weight: bold">in</span> <span style="color: #336666">range</span>(<span style="color: #336666">self</span><span style="color: #555555">.</span>K)])
    <span style="color: #336666">self</span><span style="color: #555555">.</span>cls_cond <span style="color: #555555">=</span> [get_cls_cond(k) <span style="color: #006699; font-weight: bold">for</span> k <span style="color: #000000; font-weight: bold">in</span> <span style="color: #336666">range</span>(<span style="color: #336666">self</span><span style="color: #555555">.</span>K)]
	
  <span style="color: #006699; font-weight: bold">def</span> <span style="color: #CC00FF">predict_scores</span>(<span style="color: #336666">self</span>, Xs):
    scores <span style="color: #555555">=</span> np<span style="color: #555555">.</span>zeros((<span style="color: #336666">len</span>(Xs), <span style="color: #336666">self</span><span style="color: #555555">.</span>K), <span style="color: #336666">float</span>)
    comp_score <span style="color: #555555">=</span> <span style="color: #006699; font-weight: bold">lambda</span> k, X: <span style="color: #336666">self</span><span style="color: #555555">.</span>pis[k] <span style="color: #555555">*</span> <span style="color: #336666">self</span><span style="color: #555555">.</span>cls_cond[k]<span style="color: #555555">.</span>pdf(X)
    <span style="color: #006699; font-weight: bold">for</span> i <span style="color: #000000; font-weight: bold">in</span> <span style="color: #336666">range</span>(<span style="color: #336666">len</span>(Xs)):
      scores[i] <span style="color: #555555">=</span> np<span style="color: #555555">.</span>stack([comp_score(k, Xs[i]) <span style="color: #006699; font-weight: bold">for</span> k <span style="color: #000000; font-weight: bold">in</span> <span style="color: #336666">range</span>(<span style="color: #336666">self</span><span style="color: #555555">.</span>K)])
    <span style="color: #006699; font-weight: bold">return</span> scores

  <span style="color: #006699; font-weight: bold">def</span> <span style="color: #CC00FF">predict</span>(<span style="color: #336666">self</span>, Xs):
    <span style="color: #006699; font-weight: bold">return</span> np<span style="color: #555555">.</span>argmax(<span style="color: #336666">self</span><span style="color: #555555">.</span>predict_scores(Xs), axis<span style="color: #555555">=</span><span style="color: #FF6600">1</span>)

  <span style="color: #006699; font-weight: bold">def</span> <span style="color: #CC00FF">accuracy</span>(<span style="color: #336666">self</span>, Xs, ys):
    <span style="color: #006699; font-weight: bold">return</span> np<span style="color: #555555">.</span>mean(<span style="color: #336666">self</span><span style="color: #555555">.</span>predict(Xs) <span style="color: #555555">==</span> ys)
</pre></div>

<h3 id="visualisation">Visualisation</h3>

<p><img src="https://github.com/AndreeaMusat/AndreeaMusat.github.io/blob/master/img/generative_classification_gaussian.png" alt="Probabilities" /></p>

<h4 id="credits">Credits</h4>


      </article>

      

      
        <!-- Check if any share-links are active -->




<section id = "social-share-section">
  <span class="sr-only">Share: </span>

  
  <!--- Share on Twitter -->
    <a href="https://twitter.com/intent/tweet?text=Generative+methods+for+classification&url=http%3A%2F%2Flocalhost%3A4000%2F2020-02-15-generative-classification%2F"
      class="btn btn-social-icon btn-twitter" title="Share on Twitter">
      <span class="fa fa-fw fa-twitter" aria-hidden="true"></span>
      <span class="sr-only">Twitter</span>
    </a>
  

  
  <!--- Share on Facebook -->
    <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2F2020-02-15-generative-classification%2F"
      class="btn btn-social-icon btn-facebook" title="Share on Facebook">
      <span class="fa fa-fw fa-facebook" aria-hidden="true"></span>
      <span class="sr-only">Facebook</span>
    </a>
  

  
  <!--- Share on LinkedIn -->
    <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2F2020-02-15-generative-classification%2F"
      class="btn btn-social-icon btn-linkedin" title="Share on LinkedIn">
      <span class="fa fa-fw fa-linkedin" aria-hidden="true"></span>
      <span class="sr-only">LinkedIn</span>
    </a>
  

</section>



      

      <ul class="pager blog-pager">
        
        
      </ul>

      
        <div class="disqus-comments">
          
        </div>
          
        <div class="staticman-comments">
          

        </div>
        <div class="justcomments-comments">
          
        </div>
      
    </div>
  </div>
</div>


    <footer>
  <div class="container beautiful-jekyll-footer">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links"><li><a href="mailto:andreea.a.musat@gmail.com" title="Email me"><span class="fa-stack fa-lg" aria-hidden="true">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                </span>
                <span class="sr-only">Email me</span>
              </a>
            </li><li><a href="https://github.com/andreeaAM" title="GitHub"><span class="fa-stack fa-lg" aria-hidden="true">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                </span>
                <span class="sr-only">GitHub</span>
              </a>
            </li><li><a href="https://linkedin.com/in/andreea-alexandra-muşat-74530111b" title="LinkedIn"><span class="fa-stack fa-lg" aria-hidden="true">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                </span>
                <span class="sr-only">LinkedIn</span>
              </a>
            </li></ul>
      <p class="copyright text-muted">
      Andreea Mușat
      &nbsp;&bull;&nbsp;
      2020

      
      &nbsp;&bull;&nbsp;
      <a href="http://localhost:4000/">andreeamusat.github.io</a>
      

      
      </p>
          <!-- Please don't remove this, keep my open source work credited :) -->
    <p class="theme-by text-muted">
      Theme by
      <a href="https://deanattali.com/beautiful-jekyll/">beautiful-jekyll</a>
    </p>
      </div>
    </div>
  </div>
</footer>

  
    


  
    <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
    
      <script>
      	if (typeof jQuery == 'undefined') {
          document.write('<script src="/js/jquery-1.11.2.min.js"></scr' + 'ipt>');
      	}
      </script>
    
  
    <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
    
      <script src="/js/bootstrap.min.js"></script>
    
  
    <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
    
      <script src="/js/main.js"></script>
    
  






  
  </body>
</html>
